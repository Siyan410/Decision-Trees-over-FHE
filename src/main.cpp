#include "utils.h"
#include "decision_tree_node.h"
#include "tree_eval_server.h"
#include "soft_if.h"
#include "fhe_client.h"
#include "tree_train_server.h"
#include <fstream>
#include <utility>

#undef SEAL_THROW_ON_TRANSPARENT_CIPHERTEXT

int main() {
    // Data parameters. Set features_count and labels_count to match the data provided,
    // as the algorithm doesn't infer them from the data.
    string plain_file_full_path = "../data/default_data.csv";
    int features_count = 2;
    int labels_count = 2;

    // SEAL and Soft_if parameters. Check out https://tinyurl.com/seal-params for more information about those.
    int polyModulusDegree = 15;
    int scale = 50;
    vector<int> bitSizes = { 60, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 60 };
    int soft_if_degree = 16; // The polynomial degree of the soft-if function (currently accepts 8, 16, and 32).

    // Tree training and prediction parameters.
    double split_step_size = 0.5; // step size between each different function split, all splits in range (-1, 1).
    int tree_height = 4; // The desired height of the trained tree
    stringstream data_stream; // Datastream to serialize and deserialize the encrypted tree at.
    string plain_tree_path = "../plain_tree.txt"; // Path for saving encrypted tree at.


    // ------------------------------ TREE TRAINING ------------------------------ //


    cout << "Starting training..." << endl;

    // Creating a client instance, according to the parameters.
    fhe_client client(scale, polyModulusDegree, bitSizes, split_step_size);

    // Encrypting the data on client-side, and delivering the public keys of the encryption for the server-side training.
    cout << "Client processing data..." << endl;
    vector<Sample<Ciphertext>> enc_data = client.get_encrypted_data(plain_file_full_path, features_count, labels_count);
    PublicKeys client_public_keys = client.get_public_keys();

    // Creating a server instance, and a context for the encrypted data, with the public keys
    // and relevant info about the data and desired tree height.
    tree_train_server train_server(scale, polyModulusDegree, bitSizes, client_public_keys, client,
                             features_count, labels_count, tree_height, soft_if_degree, enc_data, split_step_size);

    // Training a tree server-side, and saving it to the datastream.
    cout << "Server training on data..." << endl;
    train_server.execute(data_stream);
    cout << "Tree streamed to client. " << endl;

    // Decrypting and saving the trained tree provided from the server on client-side.
    cout << "Client decrypting and saving trained tree..." << endl;
    client.decrypt_and_save_tree(data_stream, plain_tree_path);

    cout << "Training complete!" << endl << endl;


    // ------------------------------ PREDICTION ON TRAINED TREE ------------------------------ //


    cout << "Starting prediction..." << endl;


    // NOTE: In this example, we use the same decision tree generated by the training above. The same can be done with
    // other saved decision trees by the client.

    // Generating a random input x to predict.
    cout << "Client decrypting instance..." << endl;
    vector<double> x(features_count, 0);
    vector<Ciphertext> cipher_x = client.encrypt_instance(x);

    // Creating a tree_eval_server instance, needed for prediction. Using the same seal and soft-if parameters as
    // in the training and input encryption is not required, as you can use weaker parameters if possible.
    tree_eval_server eval_server(scale, polyModulusDegree, bitSizes, soft_if_degree, client_public_keys);

    // Predicting using the tree_eval server on the decrypted trained tree, using the same public keys.
    cout << "Eval server loading tree and predicting on instance..." << endl;
    Ciphertext eval_result = eval_server.execute(plain_tree_path, cipher_x);

    // Decrypting and showing the result.
    cout << "Client decrypting result..." << endl;
    vector<double> result = client.decrypt_prediction(eval_result);

    cout << "Prediction result:" << endl;
    print_vector(result, true, 3);
}